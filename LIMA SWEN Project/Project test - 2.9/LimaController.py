import DatabaseHandler as db
from datetime import datetime  # Added import for datetime module
data = db.DataBaseHandler()  ## due to how the DatabaseHandler is set up, this is the only way to access it (this comment was generated by AI)


def sendAvailableLiquors(): ## used externally with UI
    return data.GetLiquorInv()     ## currently just sends the shit to UI with no preformatting

def sendOrderHistory(): ## used externally with UI
    if len(data.GetOrderHistory()) > 0:
        return data.GetOrderHistory() ## i have no idea what will be sent with this idk blame keoki :P (jk keoki)
    else:
        return "No Order History"

def ContainerUnbundle(containerNames): ## used externally with UI, should take container_names and just do the hacky code thing

    save_container = []  ## empty list to add into, should represent the current saved data from current GUI session
    ID = 0  ## since the UI does not actually use the ID in any way, currently writes the ID's back into lists
    for container in containerNames:
        # Retrieve the data from the containers
        name = container.content.controls[0].value ## these first few lines are hacking at the containers sent from the UI to get the raw text data
        size = container.content.controls[1].value
        quantity = container.content.controls[2].content.controls[1].value
        # Append the data to the container list, due to the way we aquire the text, we must use python to explicit data derive and strip excess text
        save_container.append([str(f'{ID:03d}').strip(), str(name[6:]).replace("'", "").strip(), str(size[6:]).replace("'", "").strip(),
                            int(quantity)])  # this method uses explicit slicing which is REALLY BAD since if the name_label gets edited, this will break
        ID += 1
    
    process_Inv = FormatLiquorInv(save_container)  ## the formatted inv list for functional comparisons
    stored_Inv = FormatLiquorInv(data.GetLiquorInv()) ## the currently not-saved-over stored data

    OrderBundle = []  ## final order list sent to datahandler, is only appended once before sent
    tempBundle = [] ## temporary order list for appending into
    if len(data.GetOrderHistory()) > 0:  ## if we have something in the file, calc the new entry ID
        OrderID = int(getLatestOrder()[0]) + 1
    else:
        OrderID = 0
    tempBundle.append([int(OrderID), (datetime.now()).strftime("%Y-%m-%d %H:%M:%S")])  ## all new order entries start with [OrderID, datetime] 
    for i in range( len(process_Inv)  ):  ## an int i is itterated over the indexes of the process_Inv list, rlly shitty algo to visit every item in the list
        try:
            if process_Inv[i][0] == stored_Inv[i][0]:  ## if the new data and old data share a liquor ID
                ItemID = process_Inv[i][0]
                CountDifference = process_Inv[i][3] - stored_Inv[i][3]
                if CountDifference > 0:  ## python has no switch statement, elseif statements are used instead
                    CountDifference = "+" + str(CountDifference) # format to string if count is positive
                    CountDifference = CountDifference.strip("'") ## always remember to format the text
                elif CountDifference < 0:
                    CountDifference = str(CountDifference) # format to string if count is negative
                    CountDifference = CountDifference.strip("'")
                else : continue  ## this skips writing an entry if there is no difference
                tempBundle.append([str(f'{ItemID:03d}').strip(), CountDifference]) ## append the shakanery we just did, int i is incremented
        except IndexError: ## ok so basically we wait for the stored list to go out of index before we add the whole new items
            ItemID = process_Inv[i][0]
            tempBundle.append([str(f'{ItemID:03d}').strip(), "+" + str(process_Inv[i][3])])
    #OrderBundle.append(tempBundle) ## the ONE append to OrderBundle, makes sure every counter difference is recorded into a single entry
    data.SaveLiquorInv(save_container, tempBundle) ## we always save the string variant LiquorInvList so thats whats passed
    return 0

def FormatOrderHistory(savedList): ## this would take the save_container and compare with the current data.GetLiquorInv()
    return 0

def saveData(list1, list2):  # used internally to write to DataHandler
    return data.SaveLiquorInv(list1, list2)

def FormatLiquorInv(InventoryList): ## internal, input the inventory list(4 items per "row"), outputs the inventory list but all entries are data typed
    typeList = []
    for row in InventoryList:
        #this was a separate method "rowUnpacker(row, list) which returned the unpacked list"
        item_id, item_name, item_size, quantity = row
        item_id = item_id.replace("'", "")
        item_name = item_name.replace("'", "") 
        item_size  = item_size.replace("'", "")
        typeList.append([int(item_id), str(item_name), float(item_size.strip("mL'")), int(quantity)])
        #this is written explicitly due to the assumtion that this method will be only used in FormatLiquorInv
    return typeList

def sendLatestOrderTime():  ## used externally with UI, sends the last available date time formatted using strftime("%Y-%m-%d %H:%M:%S")
    orders = data.GetOrderHistory()
    for row in reversed(orders):
        try:
            if int(row[0]) >= 0:
                return row[1].replace("'", "").strip()
        except ValueError:
            pass
    return None

def getLatestOrder(): ## used internally to idk i forgot
    orders = data.GetOrderHistory()
    for row in reversed(orders):
        try:
            if int(row[0]) >= 0:
                return row
        except ValueError:
            pass
    return None
## data.SaveNewLiquorIDList
## data.GetOrderHistory
## data.GetAllLiquors  ## is liq ID list
## data.GetLiquorInv
## data.SaveLiquorInv

'''
        de_container = []
        ID = 0
        for container in container_names:
            # Retrieve the data from the containers
            name = container.content.controls[0].value
            size = container.content.controls[1].value
            quantity = container.content.controls[2].content.controls[1].value
            # Append the data to the container list
            de_container.append([int(f'{ID:03d}'), str(name[6:]).replace("'", "").strip(), str(size[6:]).replace("'", "").strip(),  ## strip()
                                int(quantity)])  # this method uses explicit slicing which is REALLY BAD since if the name_label gets edited, this will break
            ID += 1
        # Save the modified data back to the database using lc.saveData()
        print(de_container)
        lc.saveData(de_container, ["id", "change"])

## .replace("'", "").strip() must be redefined into variable
# (', '.join(strings))


controller = DataBaseHandler()
newLiquorList = [["001","tito's","1L","6"], ["006","Tanquaray","1L","2"], ["005","Deep Eddy's Lemon","1.5L","3"],["012","Extoico Reposado","1.75L","0"]]
changesList = [["O002","[Date HERE]"],["001","+3"], ["002","+3"],["005","-1"]] ## this is one entry into OrderHistory

print(controller.SaveLiquorInv(newLiquorList, changesList))
print(controller.GetOrderHistory())
print(controller.GetLiquorInv())
dave = controller.GetLiquorInv()
print(dave[0][3])
for each in  dave:
    print(each)

'''